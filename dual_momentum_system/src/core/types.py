"""
Common types, enums, and dataclasses for the dual momentum framework.

This module contains all shared data structures used throughout the system.
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

import pandas as pd


class AssetType(Enum):
    """Enumeration of supported asset types."""
    EQUITY = "equity"
    BOND = "bond"
    COMMODITY = "commodity"
    CRYPTO = "crypto"
    FX = "fx"
    ALTERNATIVE = "alternative"
    REAL_ESTATE = "real_estate"


class MomentumType(Enum):
    """Types of momentum calculations."""
    ABSOLUTE = "absolute"
    RELATIVE = "relative"
    DUAL = "dual"
    CUSTOM = "custom"


class SignalType(Enum):
    """Trading signal types."""
    LONG = 1
    SHORT = -1
    NEUTRAL = 0
    EXIT = 0


class SignalReason(Enum):
    """
    Reason for signal generation.
    
    Helps distinguish between different signal generation logic
    for better debugging and performance attribution.
    """
    MOMENTUM_POSITIVE = "momentum_positive"  # Asset has positive momentum
    MOMENTUM_NEGATIVE = "momentum_negative"  # Asset has negative momentum
    RELATIVE_TOP = "relative_top"  # Top asset by relative momentum
    DEFENSIVE_ROTATION = "defensive_rotation"  # Rotating to safe asset
    NO_OPPORTUNITIES = "no_opportunities"  # No valid opportunities, hold cash/safe
    BLEND_ALLOCATION = "blend_allocation"  # Blended allocation (partial risky/safe)
    REBALANCING = "rebalancing"  # Periodic rebalancing
    RISK_LIMIT = "risk_limit"  # Risk limit triggered
    EMERGENCY_EXIT = "emergency_exit"  # Emergency stop triggered
    CUSTOM = "custom"  # Custom reason


@dataclass
class AssetMetadata:
    """
    Metadata for an asset.
    
    Attributes:
        symbol: Asset ticker/symbol
        name: Full name of the asset
        asset_type: Type of asset (equity, bond, etc.)
        exchange: Exchange where asset is traded
        currency: Base currency for pricing
        multiplier: Contract multiplier (for futures, options)
        tick_size: Minimum price increment
        lot_size: Minimum trading unit
        trading_hours: Dict with trading session information
        additional_info: Any additional asset-specific metadata
    """
    symbol: str
    name: str
    asset_type: AssetType
    exchange: Optional[str] = None
    currency: str = "USD"
    multiplier: float = 1.0
    tick_size: float = 0.01
    lot_size: float = 1.0
    trading_hours: Optional[Dict[str, Any]] = None
    additional_info: Optional[Dict[str, Any]] = None


@dataclass
class PriceData:
    """
    Container for price data with validation.
    
    Attributes:
        symbol: Asset symbol
        data: DataFrame with OHLCV data (required columns: open, high, low, close, volume)
        metadata: AssetMetadata object
        timeframe: Data timeframe (e.g., '1d', '1h', '5m')
    """
    symbol: str
    data: pd.DataFrame
    metadata: AssetMetadata
    timeframe: str = "1d"
    
    def __post_init__(self):
        """Validate price data structure."""
        required_cols = ['open', 'high', 'low', 'close', 'volume']
        missing = [col for col in required_cols if col not in self.data.columns]
        if missing:
            raise ValueError(f"Missing required columns: {missing}")
        
        if not isinstance(self.data.index, pd.DatetimeIndex):
            raise ValueError("Data index must be a DatetimeIndex")
        
        # Ensure data is sorted by date
        if not self.data.index.is_monotonic_increasing:
            self.data = self.data.sort_index()
    
    def get_close(self) -> pd.Series:
        """Get close prices."""
        return self.data['close']
    
    def get_returns(self) -> pd.Series:
        """Calculate simple returns."""
        return self.data['close'].pct_change()
    
    def get_log_returns(self) -> pd.Series:
        """Calculate logarithmic returns."""
        return pd.Series(
            pd.np.log(self.data['close'] / self.data['close'].shift(1)),
            index=self.data.index
        )


@dataclass
class Signal:
    """
    Trading signal generated by a strategy.
    
    Attributes:
        timestamp: When signal was generated
        symbol: Asset symbol
        direction: Signal direction (1=long, -1=short, 0=neutral/exit)
        strength: Signal confidence/strength (0.0 to 1.0)
        reason: Reason for signal generation (for debugging/attribution)
        confidence: Confidence level in signal (0.0 to 1.0)
        blend_ratio: Optional ratio for blended allocation (0.0=all safe, 1.0=all risky)
        alternatives: Optional list of alternative assets that were considered
        metadata: Additional signal information (momentum scores, indicators, etc.)
    """
    timestamp: datetime
    symbol: str
    direction: int  # 1 for long, -1 for short, 0 for neutral/exit
    strength: float  # Signal strength/confidence (0.0 to 1.0)
    reason: SignalReason = SignalReason.CUSTOM
    confidence: float = 1.0  # Confidence level (0.0 to 1.0)
    blend_ratio: Optional[float] = None  # For partial allocations (0.0 to 1.0)
    alternatives: Optional[List[str]] = None  # Alternative assets considered
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        """Validate signal parameters."""
        if self.direction not in [-1, 0, 1]:
            raise ValueError(f"Direction must be -1, 0, or 1, got {self.direction}")
        
        if not 0.0 <= self.strength <= 1.0:
            raise ValueError(f"Strength must be between 0.0 and 1.0, got {self.strength}")
        
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError(f"Confidence must be between 0.0 and 1.0, got {self.confidence}")
        
        if self.blend_ratio is not None and not 0.0 <= self.blend_ratio <= 1.0:
            raise ValueError(f"Blend ratio must be between 0.0 and 1.0, got {self.blend_ratio}")
    
    @property
    def is_long(self) -> bool:
        """Check if signal is long."""
        return self.direction == 1
    
    @property
    def is_short(self) -> bool:
        """Check if signal is short."""
        return self.direction == -1
    
    @property
    def is_exit(self) -> bool:
        """Check if signal is exit/neutral."""
        return self.direction == 0
    
    @property
    def is_defensive(self) -> bool:
        """Check if signal is for defensive positioning (safe asset)."""
        return self.reason == SignalReason.DEFENSIVE_ROTATION
    
    @property
    def is_blended(self) -> bool:
        """Check if signal is for blended allocation."""
        return self.blend_ratio is not None and 0.0 < self.blend_ratio < 1.0


@dataclass
class Position:
    """
    Represents a trading position.
    
    Attributes:
        symbol: Asset symbol
        quantity: Number of units (positive for long, negative for short)
        entry_price: Price at entry
        entry_timestamp: When position was opened
        current_price: Current market price
        current_timestamp: Current timestamp
        metadata: Additional position information
    """
    symbol: str
    quantity: float
    entry_price: float
    entry_timestamp: datetime
    current_price: float
    current_timestamp: datetime
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    @property
    def market_value(self) -> float:
        """Calculate current market value."""
        return self.current_price * abs(self.quantity)
    
    @property
    def pnl(self) -> float:
        """Calculate unrealized P&L."""
        return (self.current_price - self.entry_price) * self.quantity
    
    @property
    def pnl_pct(self) -> float:
        """Calculate unrealized P&L percentage."""
        if self.entry_price == 0:
            return 0.0
        return (self.current_price - self.entry_price) / self.entry_price * 100
    
    @property
    def is_long(self) -> bool:
        """Check if position is long."""
        return self.quantity > 0
    
    @property
    def is_short(self) -> bool:
        """Check if position is short."""
        return self.quantity < 0


@dataclass
class Trade:
    """
    Represents a completed trade.
    
    Attributes:
        symbol: Asset symbol
        entry_timestamp: Entry time
        exit_timestamp: Exit time
        entry_price: Entry price
        exit_price: Exit price
        quantity: Trade size
        pnl: Realized profit/loss
        pnl_pct: Realized P&L percentage
        direction: Trade direction (1=long, -1=short)
        metadata: Additional trade information
    """
    symbol: str
    entry_timestamp: datetime
    exit_timestamp: datetime
    entry_price: float
    exit_price: float
    quantity: float
    pnl: float
    pnl_pct: float
    direction: int
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    @property
    def duration(self) -> pd.Timedelta:
        """Calculate trade duration."""
        return self.exit_timestamp - self.entry_timestamp
    
    @property
    def is_winner(self) -> bool:
        """Check if trade was profitable."""
        return self.pnl > 0


@dataclass
class BacktestResult:
    """
    Results from a backtest run.
    
    Attributes:
        strategy_name: Name of the strategy
        start_date: Backtest start date
        end_date: Backtest end date
        initial_capital: Starting capital
        final_capital: Ending capital
        returns: Series of period returns
        positions: DataFrame of positions over time
        trades: DataFrame of completed trades
        metrics: Dictionary of performance metrics
        equity_curve: Series of portfolio value over time
        metadata: Additional backtest information
    """
    strategy_name: str
    start_date: datetime
    end_date: datetime
    initial_capital: float
    final_capital: float
    returns: pd.Series
    positions: pd.DataFrame
    trades: pd.DataFrame
    metrics: Dict[str, float]
    equity_curve: pd.Series
    benchmark_curve: Optional[pd.Series] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    @property
    def total_return(self) -> float:
        """Calculate total return."""
        return (self.final_capital - self.initial_capital) / self.initial_capital
    
    @property
    def num_trades(self) -> int:
        """Get number of trades."""
        return len(self.trades)
    
    @property
    def winning_trades(self) -> int:
        """Get number of winning trades."""
        if 'pnl' in self.trades.columns:
            return (self.trades['pnl'] > 0).sum()
        return 0
    
    @property
    def win_rate(self) -> float:
        """Calculate win rate."""
        if self.num_trades == 0:
            return 0.0
        return self.winning_trades / self.num_trades


@dataclass
class PortfolioState:
    """
    Current state of the portfolio.
    
    Attributes:
        timestamp: Current timestamp
        cash: Available cash
        positions: Dictionary of current positions
        portfolio_value: Total portfolio value
        metadata: Additional portfolio information
    """
    timestamp: datetime
    cash: float
    positions: Dict[str, Position]
    portfolio_value: float
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    @property
    def invested_value(self) -> float:
        """Calculate total invested value."""
        return sum(pos.market_value for pos in self.positions.values())
    
    @property
    def num_positions(self) -> int:
        """Get number of open positions."""
        return len(self.positions)
    
    @property
    def leverage(self) -> float:
        """Calculate portfolio leverage."""
        if self.portfolio_value == 0:
            return 0.0
        return self.invested_value / self.portfolio_value
