"""
Core abstract base classes for the dual momentum backtesting framework.

This module defines the foundational interfaces that enable the plugin architecture.
All custom implementations should inherit from these base classes.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Protocol, Union

import pandas as pd
import numpy as np


class AssetType(Enum):
    """Enumeration of supported asset types."""
    EQUITY = "equity"
    BOND = "bond"
    COMMODITY = "commodity"
    CRYPTO = "crypto"
    FX = "fx"
    ALTERNATIVE = "alternative"
    REAL_ESTATE = "real_estate"


class MomentumType(Enum):
    """Types of momentum calculations."""
    ABSOLUTE = "absolute"
    RELATIVE = "relative"
    DUAL = "dual"


@dataclass
class AssetMetadata:
    """Metadata for an asset."""
    symbol: str
    name: str
    asset_type: AssetType
    exchange: Optional[str] = None
    currency: str = "USD"
    multiplier: float = 1.0
    tick_size: float = 0.01
    lot_size: float = 1.0
    trading_hours: Optional[Dict[str, Any]] = None
    additional_info: Optional[Dict[str, Any]] = None


@dataclass
class PriceData:
    """Container for price data."""
    symbol: str
    data: pd.DataFrame  # Expected columns: open, high, low, close, volume
    metadata: AssetMetadata
    timeframe: str = "1d"
    
    def __post_init__(self):
        """Validate price data structure."""
        required_cols = ['open', 'high', 'low', 'close', 'volume']
        missing = [col for col in required_cols if col not in self.data.columns]
        if missing:
            raise ValueError(f"Missing required columns: {missing}")
        
        if not isinstance(self.data.index, pd.DatetimeIndex):
            raise ValueError("Data index must be a DatetimeIndex")


@dataclass
class Signal:
    """Trading signal generated by a strategy."""
    timestamp: datetime
    symbol: str
    direction: int  # 1 for long, -1 for short, 0 for neutral/exit
    strength: float  # Signal strength/confidence (0.0 to 1.0)
    metadata: Dict[str, Any]


@dataclass
class Position:
    """Represents a trading position."""
    symbol: str
    quantity: float
    entry_price: float
    entry_timestamp: datetime
    current_price: float
    current_timestamp: datetime
    metadata: Dict[str, Any]
    
    @property
    def pnl(self) -> float:
        """Calculate unrealized P&L."""
        return (self.current_price - self.entry_price) * self.quantity
    
    @property
    def pnl_pct(self) -> float:
        """Calculate unrealized P&L percentage."""
        if self.entry_price == 0:
            return 0.0
        return (self.current_price - self.entry_price) / self.entry_price


@dataclass
class BacktestResult:
    """Results from a backtest run."""
    strategy_name: str
    start_date: datetime
    end_date: datetime
    initial_capital: float
    final_capital: float
    returns: pd.Series
    positions: pd.DataFrame
    trades: pd.DataFrame
    metrics: Dict[str, float]
    equity_curve: pd.Series
    metadata: Dict[str, Any]


class AssetClass(ABC):
    """
    Abstract base class for asset classes.
    
    Each asset class plugin should inherit from this class and implement
    the required methods to handle asset-specific logic.
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        Initialize the asset class.
        
        Args:
            config: Configuration dictionary for the asset class
        """
        self.config = config or {}
        self._validate_config()
    
    @abstractmethod
    def get_asset_type(self) -> AssetType:
        """Return the asset type this class handles."""
        pass
    
    @abstractmethod
    def validate_symbol(self, symbol: str) -> bool:
        """
        Validate if a symbol is valid for this asset class.
        
        Args:
            symbol: Asset symbol to validate
            
        Returns:
            True if valid, False otherwise
        """
        pass
    
    @abstractmethod
    def get_metadata(self, symbol: str) -> AssetMetadata:
        """
        Get metadata for an asset.
        
        Args:
            symbol: Asset symbol
            
        Returns:
            AssetMetadata object
        """
        pass
    
    @abstractmethod
    def normalize_data(self, data: pd.DataFrame, symbol: str) -> PriceData:
        """
        Normalize raw data to the standard PriceData format.
        
        Args:
            data: Raw price data
            symbol: Asset symbol
            
        Returns:
            Normalized PriceData object
        """
        pass
    
    def calculate_returns(self, price_data: PriceData) -> pd.Series:
        """
        Calculate returns from price data.
        
        Args:
            price_data: Price data object
            
        Returns:
            Series of returns
        """
        return price_data.data['close'].pct_change()
    
    def _validate_config(self) -> None:
        """Validate configuration. Override if needed."""
        pass
    
    @classmethod
    def get_name(cls) -> str:
        """Return the plugin name."""
        return cls.__name__


class DataSource(ABC):
    """
    Abstract base class for data sources.
    
    Data source plugins should inherit from this class and implement
    methods to fetch and process data from various providers.
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        Initialize the data source.
        
        Args:
            config: Configuration dictionary
        """
        self.config = config or {}
        self._validate_config()
    
    @abstractmethod
    def fetch_data(
        self,
        symbol: str,
        start_date: datetime,
        end_date: datetime,
        timeframe: str = "1d"
    ) -> pd.DataFrame:
        """
        Fetch historical price data.
        
        Args:
            symbol: Asset symbol
            start_date: Start date for data
            end_date: End date for data
            timeframe: Data timeframe (e.g., '1d', '1h', '5m')
            
        Returns:
            DataFrame with OHLCV data
        """
        pass
    
    @abstractmethod
    def get_supported_assets(self) -> List[str]:
        """
        Get list of supported asset symbols.
        
        Returns:
            List of supported symbols
        """
        pass
    
    def is_available(self) -> bool:
        """
        Check if the data source is available.
        
        Returns:
            True if available, False otherwise
        """
        return True
    
    def _validate_config(self) -> None:
        """Validate configuration. Override if needed."""
        pass
    
    @classmethod
    def get_name(cls) -> str:
        """Return the data source name."""
        return cls.__name__


class MomentumStrategy(ABC):
    """
    Abstract base class for momentum strategies.
    
    Strategy plugins should inherit from this class and implement
    the momentum calculation and signal generation logic.
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        Initialize the strategy.
        
        Args:
            config: Strategy configuration
        """
        self.config = config or {}
        self._validate_config()
        self.name = self.get_name()
    
    @abstractmethod
    def calculate_momentum(
        self,
        price_data: Union[PriceData, Dict[str, PriceData]]
    ) -> Union[pd.Series, Dict[str, pd.Series]]:
        """
        Calculate momentum score(s).
        
        Args:
            price_data: Price data for one or more assets
            
        Returns:
            Momentum scores as Series or dict of Series
        """
        pass
    
    @abstractmethod
    def generate_signals(
        self,
        price_data: Union[PriceData, Dict[str, PriceData]]
    ) -> List[Signal]:
        """
        Generate trading signals based on momentum.
        
        Args:
            price_data: Price data for one or more assets
            
        Returns:
            List of trading signals
        """
        pass
    
    @abstractmethod
    def get_momentum_type(self) -> MomentumType:
        """Return the type of momentum strategy."""
        pass
    
    def get_required_history(self) -> int:
        """
        Get the number of periods required for calculation.
        
        Returns:
            Number of required periods
        """
        return 252  # Default to 1 year daily data
    
    def _validate_config(self) -> None:
        """Validate configuration. Override if needed."""
        pass
    
    @classmethod
    def get_name(cls) -> str:
        """Return the strategy name."""
        return cls.__name__


class RiskManager(ABC):
    """
    Abstract base class for risk management.
    
    Risk manager plugins should implement position sizing,
    risk limits, and portfolio constraints.
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        Initialize the risk manager.
        
        Args:
            config: Risk management configuration
        """
        self.config = config or {}
        self._validate_config()
    
    @abstractmethod
    def calculate_position_size(
        self,
        signal: Signal,
        portfolio_value: float,
        current_positions: Dict[str, Position]
    ) -> float:
        """
        Calculate position size based on risk parameters.
        
        Args:
            signal: Trading signal
            portfolio_value: Current portfolio value
            current_positions: Dictionary of current positions
            
        Returns:
            Position size (number of units)
        """
        pass
    
    @abstractmethod
    def check_risk_limits(
        self,
        portfolio_value: float,
        current_positions: Dict[str, Position],
        proposed_trade: Optional[Signal] = None
    ) -> bool:
        """
        Check if risk limits are satisfied.
        
        Args:
            portfolio_value: Current portfolio value
            current_positions: Current positions
            proposed_trade: Proposed trade signal (if any)
            
        Returns:
            True if within risk limits, False otherwise
        """
        pass
    
    @abstractmethod
    def get_max_leverage(self) -> float:
        """
        Get maximum allowed leverage.
        
        Returns:
            Maximum leverage ratio
        """
        pass
    
    def adjust_for_volatility(
        self,
        position_size: float,
        volatility: float,
        target_volatility: float
    ) -> float:
        """
        Adjust position size based on volatility targeting.
        
        Args:
            position_size: Base position size
            volatility: Asset volatility
            target_volatility: Target portfolio volatility
            
        Returns:
            Adjusted position size
        """
        if volatility == 0:
            return 0
        return position_size * (target_volatility / volatility)
    
    def _validate_config(self) -> None:
        """Validate configuration. Override if needed."""
        pass
    
    @classmethod
    def get_name(cls) -> str:
        """Return the risk manager name."""
        return cls.__name__


class PerformanceMetrics:
    """Calculate performance metrics for backtest results."""
    
    @staticmethod
    def calculate_sharpe_ratio(
        returns: pd.Series,
        risk_free_rate: float = 0.0,
        periods_per_year: int = 252
    ) -> float:
        """Calculate annualized Sharpe ratio."""
        excess_returns = returns - risk_free_rate / periods_per_year
        if excess_returns.std() == 0:
            return 0.0
        return np.sqrt(periods_per_year) * excess_returns.mean() / excess_returns.std()
    
    @staticmethod
    def calculate_sortino_ratio(
        returns: pd.Series,
        risk_free_rate: float = 0.0,
        periods_per_year: int = 252
    ) -> float:
        """Calculate annualized Sortino ratio."""
        excess_returns = returns - risk_free_rate / periods_per_year
        downside_returns = excess_returns[excess_returns < 0]
        if len(downside_returns) == 0 or downside_returns.std() == 0:
            return 0.0
        return np.sqrt(periods_per_year) * excess_returns.mean() / downside_returns.std()
    
    @staticmethod
    def calculate_max_drawdown(equity_curve: pd.Series) -> float:
        """Calculate maximum drawdown."""
        cumulative = (1 + equity_curve).cumprod()
        running_max = cumulative.cummax()
        drawdown = (cumulative - running_max) / running_max
        return drawdown.min()
    
    @staticmethod
    def calculate_calmar_ratio(
        returns: pd.Series,
        periods_per_year: int = 252
    ) -> float:
        """Calculate Calmar ratio."""
        equity_curve = returns
        max_dd = abs(PerformanceMetrics.calculate_max_drawdown(equity_curve))
        if max_dd == 0:
            return 0.0
        annual_return = (1 + returns.mean()) ** periods_per_year - 1
        return annual_return / max_dd
    
    @staticmethod
    def calculate_all_metrics(
        returns: pd.Series,
        equity_curve: pd.Series,
        risk_free_rate: float = 0.0,
        periods_per_year: int = 252
    ) -> Dict[str, float]:
        """Calculate all standard performance metrics."""
        total_return = (1 + returns).prod() - 1
        annual_return = (1 + returns.mean()) ** periods_per_year - 1
        annual_volatility = returns.std() * np.sqrt(periods_per_year)
        
        return {
            'total_return': total_return,
            'annual_return': annual_return,
            'annual_volatility': annual_volatility,
            'sharpe_ratio': PerformanceMetrics.calculate_sharpe_ratio(
                returns, risk_free_rate, periods_per_year
            ),
            'sortino_ratio': PerformanceMetrics.calculate_sortino_ratio(
                returns, risk_free_rate, periods_per_year
            ),
            'max_drawdown': PerformanceMetrics.calculate_max_drawdown(equity_curve),
            'calmar_ratio': PerformanceMetrics.calculate_calmar_ratio(
                returns, periods_per_year
            ),
            'win_rate': (returns > 0).sum() / len(returns) if len(returns) > 0 else 0.0,
            'num_trades': len(returns),
        }
